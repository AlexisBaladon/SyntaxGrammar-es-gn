### Usage: python custom-generate-sentences.py --help

### Inspired by https://eli.thegreenplace.net/2010/01/28/generating-random-sentences-from-a-context-free-grammar/
from collections import defaultdict
import random
import argparse
from nltk.grammar import FeatureGrammar
from nltk.parse import FeatureEarleyChartParser, FeatureChartParser

class CFG(object):
    def __init__(self):
        self.prod = defaultdict(list)

    def add_prod(self, lhs, rhs, weight=0.1):
        """ Add production to the grammar. 'rhs' can
            be several productions separated by '|'.
            Each production is a sequence of symbols
            separated by whitespace.

            Usage:
                grammar.add_prod('NT', 'VP PP', 0.5)
                grammar.add_prod('Digit', '1|2|3|4', 0.25)
        """
        prods = rhs.split('|')
        for prod in prods:
            self.prod[lhs].append((tuple(prod.split()), weight))

    def gen_random(self, symbol):
        """ Generate a random sentence from the
            grammar, starting with the given
            symbol.
        """
        sentence = []

        # select one production of this symbol randomly, considering weights
        rand_prod = random.choices(
            population=self.prod[symbol],
            weights=[weight for _, weight in self.prod[symbol]],
            k=1
        )[0]

        for sym in rand_prod[0]:
            # for non-terminals, recurse
            if sym in self.prod:
                sentence.append(self.gen_random(sym))
            else:
                sentence.append(sym)

        return ' '.join(sentence) # Could perhaps return a list, but parser complains
            

def parse_arguments():
    parser = argparse.ArgumentParser()

    parser.add_argument('cfg_path', type=str, help='Path to the CFG grammar file')
    parser.add_argument('feature_grammar_path', type=str, help='Path to the Feature grammar file')
    parser.add_argument('-n', '--number', type=int, default=100, help='Number of sentences to generate')
    parser.add_argument('-o', '--output', type=str, default='output.txt', help='Path to the output file')
    parser.add_argument('-t', '--trees-file', type=str, default=None, help='Path to the file to write the trees to')
    parser.add_argument('-a', '--all-sentences', action='store_true', help='Print all sentences generated by CFG (regardless of validation) to stdout')

    return parser.parse_args()

def isRule(line: str):
    return (not not line) and not line.startswith("#") and not line.startswith("%")

def load_cfg_grammar(grammar_file):
    grammar = CFG()
    with open(grammar_file, "r") as file: 
        for line in file: # type: str
            line = line.strip()  # Remove leading/trailing whitespace
            if (isRule(line)):
                rule, weight = line.split("#")
                lhs, rhs = rule.split("->")
                lhs = lhs.strip()
                rhs = rhs.replace("'", "").replace('"', '').strip()
                if (weight.strip() != ''):
                    weight = float(weight.strip())
                    grammar.add_prod(lhs, rhs, weight)
                else:
                    grammar.add_prod(lhs, rhs)
    return grammar

def load_feature_grammar(grammar_file):
    feature_grammar_string = ''

    with open(grammar_file, 'r') as file:
        chunk_size = 1024  # read 1 KB at a time
        i = 0
        while True:
            chunk = file.read(chunk_size)
            if not chunk:
                break  # end of file
            feature_grammar_string += chunk

    return FeatureGrammar.fromstring(feature_grammar_string)



def main():
    args = parse_arguments()
    cfg_grammar_file = args.cfg_path
    feature_grammar_file = args.feature_grammar_path
    
    cfg_grammar = load_cfg_grammar(cfg_grammar_file)
    feat_grammar = load_feature_grammar(feature_grammar_file)
    #parser = FeatureEarleyChartParser(feat_grammar)
    parser = FeatureChartParser(feat_grammar)


    with open(args.output, 'w') as output_file:
        if args.trees_file:
            trees_file = open(args.trees_file, 'w')
        else:
            trees_file = None

        for i in range(args.number):
            sentence = cfg_grammar.gen_random('S')
            if (args.all_sentences):
                print(sentence)
            parsed = parser.parse_all(sentence.split(" "))
            if sentence and len(parsed) > 0:
                output_file.write(sentence + '\n')
                if (trees_file):
                    for tree in parsed:
                        trees_file.write(str(tree) + '\n')

        if trees_file:
            trees_file.close()

        

if __name__ == '__main__':
    main()